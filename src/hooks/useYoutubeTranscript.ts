
import { useState } from "react";
import { toast } from "sonner";
import { extractYouTubeVideoId } from "@/utils/youtubeUtils";

export function useYoutubeTranscript() {
  const [youtubeUrl, setYoutubeUrl] = useState("");
  const [transcript, setTranscript] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");

  const handleExtractTranscript = async () => {
    // Reset states
    setTranscript("");
    setError("");
    
    if (!youtubeUrl.trim()) {
      setError("YouTube URL을 입력해주세요.");
      toast.error("YouTube URL을 입력해주세요.");
      return;
    }
    
    const videoId = extractYouTubeVideoId(youtubeUrl);
    console.log("Extracted Video ID:", videoId);
    
    if (!videoId) {
      setError("유효한 YouTube URL을 입력해주세요.");
      toast.error("유효한 YouTube URL을 입력해주세요.");
      return;
    }
    
    setIsLoading(true);
    
    try {
      // 직접 YouTube의 자막 데이터 API 접근 - 가장 안정적인 방식 시도
      // 1. 지정된 언어의 자막 가져오기 시도 (한국어 먼저, 그 다음 영어)
      // 2. 자동 생성 자막 가져오기 시도
      let transcriptText = "";
      
      // 직접 API 호출 함수
      async function fetchTranscript(videoId, lang) {
        try {
          const url = `https://www.youtube.com/api/timedtext?lang=${lang}&v=${videoId}`;
          console.log(`Trying to fetch ${lang} transcript from:`, url);
          
          const response = await fetch(url);
          console.log(`${lang} transcript response status:`, response.status);
          
          if (response.ok) {
            const xmlText = await response.text();
            console.log(`${lang} transcript XML length:`, xmlText.length);
            
            // XML이 실제로 존재하는지 확인 (빈 응답이 아닌지)
            if (xmlText && xmlText.length > 100) {
              // XML 자막 파싱
              const parser = new DOMParser();
              const xmlDoc = parser.parseFromString(xmlText, "text/xml");
              const textNodes = xmlDoc.getElementsByTagName("text");
              
              if (textNodes.length > 0) {
                let fullText = "";
                for (let i = 0; i < textNodes.length; i++) {
                  // 태그 내부의 HTML 엔티티 등을 적절히 처리
                  const textContent = textNodes[i].textContent || "";
                  fullText += textContent + " ";
                }
                
                return fullText.trim();
              }
            }
          }
          return null;
        } catch (error) {
          console.error(`Error fetching ${lang} transcript:`, error);
          return null;
        }
      }
      
      // 자동 생성 자막 가져오기 시도
      async function fetchAutoGenerated(videoId) {
        try {
          const url = `https://www.youtube.com/api/timedtext?lang=ko&v=${videoId}&kind=asr`;
          console.log(`Trying to fetch auto-generated transcript:`, url);
          
          const response = await fetch(url);
          console.log(`Auto-generated transcript response status:`, response.status);
          
          if (response.ok) {
            const xmlText = await response.text();
            console.log(`Auto-generated transcript XML length:`, xmlText.length);
            
            if (xmlText && xmlText.length > 100) {
              const parser = new DOMParser();
              const xmlDoc = parser.parseFromString(xmlText, "text/xml");
              const textNodes = xmlDoc.getElementsByTagName("text");
              
              if (textNodes.length > 0) {
                let fullText = "";
                for (let i = 0; i < textNodes.length; i++) {
                  const textContent = textNodes[i].textContent || "";
                  fullText += textContent + " ";
                }
                
                return fullText.trim();
              }
            }
          }
          return null;
        } catch (error) {
          console.error("Error fetching auto-generated transcript:", error);
          return null;
        }
      }
      
      // 백업 API 시도 (Kakulukian/youtube-transcript)
      async function fetchFromBackupApi(videoId) {
        try {
          const corsProxy = "https://corsproxy.io/?";
          const apiUrl = `${corsProxy}https://youtube-transcript.vercel.app/api/transcript?videoId=${videoId}`;
          
          console.log("Trying backup API:", apiUrl);
          const response = await fetch(apiUrl);
          console.log("Backup API response status:", response.status);
          
          if (response.ok) {
            const data = await response.json();
            console.log("Backup API data:", data);
            
            if (data && data.transcript) {
              return data.transcript;
            } else if (data && data.captions && data.captions.length > 0) {
              return data.captions.map((caption) => caption.text).join(" ");
            }
          }
          return null;
        } catch (error) {
          console.error("Backup API error:", error);
          return null;
        }
      }
      
      // 각 방법을 순차적으로 시도
      
      // 1. 한국어 자막 시도
      transcriptText = await fetchTranscript(videoId, "ko");
      
      // 2. 영어 자막 시도
      if (!transcriptText) {
        transcriptText = await fetchTranscript(videoId, "en");
      }
      
      // 3. 자동 생성 자막 시도
      if (!transcriptText) {
        transcriptText = await fetchAutoGenerated(videoId);
      }
      
      // 4. 백업 API 시도
      if (!transcriptText) {
        transcriptText = await fetchFromBackupApi(videoId);
      }
      
      // 최종 결과 처리
      if (transcriptText) {
        setTranscript(transcriptText);
        toast.success("자막을 성공적으로 가져왔습니다!");
      } else {
        throw new Error("자막을 찾을 수 없습니다");
      }
      
    } catch (error) {
      console.error("자막 추출 오류:", error);
      let errorMessage = "자막을 가져오는데 실패했습니다.";
      
      if (error instanceof Error) {
        if (error.message.includes("Failed to fetch") || error.message.includes("NetworkError")) {
          errorMessage = "네트워크 연결 오류: 서버에 연결할 수 없습니다.";
        } else if (error.message.includes("자막을 찾을 수 없습니다")) {
          errorMessage = "이 영상에는 자막이 없거나 접근할 수 없습니다.";
        } else {
          errorMessage = error.message;
        }
      }
      
      setError(errorMessage);
      toast.error("자막을 가져오는데 실패했습니다.");
    } finally {
      setIsLoading(false);
    }
  };

  return {
    youtubeUrl,
    setYoutubeUrl,
    transcript,
    isLoading,
    error,
    handleExtractTranscript
  };
}
